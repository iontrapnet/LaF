// Generated by CoffeeScript 1.6.3
(function() {
  var doc, endsWith, esprima, objects;

  esprima = require('esprima');

  objects = require('lodash-node/modern/objects');

  endsWith = function(str, suffix) {
    "Checks whether a given string ends with `suffix`";
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
  };

  doc = function(val) {
    "Extracts as much documentation information from an object as possible\n\nThe docstring is determined by looking at `.__doc__` and if that is \nset, using that.\nIf that is not found, then `.constructor.__doc__` is examined, and if \nthat is not found, then the \n\nIf none of those are set, then in a function definition, \nif the first token inside the function body is a string literal,\nthen that is the docstring; if the first token is anything else,\nthen the function is not considered to have a docstring.\n";
    var docString, first, functionBodyParseTree, info, isFibrous, isNative, name, params, parseTree, s, ty, x;
    if (objects.isUndefined(val)) {
      return {
        type: "undefined"
      };
    }
    if (objects.isNull(val)) {
      return {
        type: "null"
      };
    }
    isNative = false;
    isFibrous = false;
    ty = typeof val;
    if (ty != null) {
      ty = ty.charAt(0).toUpperCase() + ty.slice(1);
    }
    if (objects.isFunction(val)) {
      if (objects.isFunction(val.__fibrousFn__)) {
        ty = "fibrous Function";
        val = val.__fibrousFn__;
        isFibrous = true;
      }
      s = val.toString();
      if (endsWith(s, ") { [native code] }")) {
        isNative = true;
        docString = "[native code]";
        s = s.replace("[native code]", "");
      }
      parseTree = esprima.parse("(" + s + ")");
      params = (function() {
        var _i, _len, _ref, _results;
        _ref = parseTree.body[0].expression.params;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          x = _ref[_i];
          _results.push(x.name);
        }
        return _results;
      })();
      functionBodyParseTree = parseTree.body[0].expression.body.body;
      if (val.__doc__ != null) {
        docString = val.__doc__.toString();
      } else {
        if ((val.constructor != null) && (val.constructor.__doc__ != null)) {
          docString = val.constructor.__doc__.toString();
        } else {
          if (docString == null) {
            docString = null;
          }
          if (functionBodyParseTree.length) {
            first = functionBodyParseTree[0];
            if (first.type === "ExpressionStatement" && first.expression.type === "Literal") {
              docString = first.expression.value;
            }
          }
        }
      }
    } else {
      if (val.__doc__ != null) {
        docString = val.__doc__.toString();
      } else {
        if ((val.constructor != null) && (val.constructor.__doc__ != null)) {
          docString = val.constructor.__doc__.toString();
        } else {
          docString = null;
        }
      }
    }
    if (val.__name__ != null) {
      name = val.__name__;
    } else {
      name = val.name;
    }
    if (objects.isArray(val)) {
      ty = "Array";
    } else {

    }
    info = {
      params: params,
      doc: docString,
      name: name,
      type: ty
    };
    if (isNative) {
      info.nativeCode = isNative;
    }
    if (isFibrous) {
      info.isFibrous = isFibrous;
    }
    if (objects.isFunction(val)) {
      info.code = val.toString();
    }
    return info;
  };

  module.exports = doc;

}).call(this);
